{
  "configs": [
    {
      "name": "mongo",
      "operators": [
        "([make] ([report]))",
        "([state])",
        "([changeState|make] ([reportElement]) (state/*))",
        "([reportElementProperty])",
        "((reportElement/* && !@<color_colors && !@<case) [compoundReportElement] (reportElement/* && !@<color_colors && !@<case))",
        "([background])",
        "([header])",
        "([table])",
        "([case])",
        "([uppercase])",
        "([lowercase])",
        "([reportable])",
        "([show] ([reportable]))",
        "([capitalize] ([reportElement]))",
        "([sales|])",
        "([year])",
        "([user])",
        "([email])",
        "([movie])",
        "([thisReportElement|this] (reportElement/*))"
      ],
      "hierarchy": [
        [
          "color_colors",
          "state"
        ],
        [
          "case",
          "state"
        ],
        [
          "color_colors",
          "reportElement"
        ],
        [
          "case",
          "reportElement"
        ]
      ],
      "bridges": [
        {
          "id": "case",
          "words": [
            {
              "word": "case",
              "number": "one"
            },
            {
              "word": "cases",
              "number": "many"
            }
          ],
          "isA": [
            "reportElementProperty"
          ]
        },
        {
          "id": "uppercase",
          "words": [
            {
              "word": "upper",
              "number": "one",
              "value": "uppercase"
            },
            {
              "word": "uppers",
              "number": "many",
              "value": "uppercase"
            }
          ],
          "isA": [
            "case"
          ]
        },
        {
          "id": "lowercase",
          "words": [
            {
              "word": "lower",
              "number": "one",
              "value": "lowercase"
            },
            {
              "word": "lowers",
              "number": "many",
              "value": "lowercase"
            }
          ],
          "isA": [
            "case"
          ]
        },
        {
          "id": "reportElementProperty"
        },
        {
          "id": "compoundReportElement",
          "convolution": true,
          "isA": [
            "reportElement",
            "theAble"
          ],
          "bridge": "{ ...next(operator), reportElements: append(default(before[0].reportElements, [before[0]]), default(after[0].reportElements, [after[0]])) }",
          "generatorp": "({context, g, gs}) => gs(context.reportElements)"
        },
        {
          "id": "make",
          "bridge": "{ ...next(operator), report: after[0] }",
          "parents": [
            "verby"
          ],
          "generatorp": "({context, g}) => `make ${g(context.report)}`",
          "semantic": "({context, km, api}) => {\n        api.newReport()\n      }"
        },
        {
          "id": "state",
          "bridge": "{ ...next(operator) }"
        },
        {
          "id": "thisReportElement",
          "parents": [
            "articlePOS"
          ],
          "bridge": "{ ...next(after[0]), modifiers: append(['this'], after[0].modifiers), this: operator }"
        },
        {
          "id": "changeState",
          "bridge": "{ ...next(operator), reportElement: after[0], newState: after[1] }",
          "parents": [
            "verby"
          ],
          "generatorp": "({context, g}) => `make ${g(context.reportElement)} ${g(context.newState)}`",
          "semantic": "({context, km, api, isA}) => {\n        const getProperty = (reportElements, state) => {\n          let property;\n          debugger\n          for (const re of reportElements) {\n            if (isA(re.marker, 'reportElementProperty')) {\n              if (re.marker == 'background') {\n                property = 'background-color' \n                break;\n              } if (isA(re.marker, 'case')) {\n                property = 'text-transform' \n                break;\n              } if (re.marker == 'color') {\n                property = 'color' \n                break;\n              }\n            }\n          }\n          if (!property) {\n            if (isA(state.marker, 'color_colors')) {\n              return 'color'\n            }\n            if (isA(state.marker, 'case')) {\n              return 'text-transform'\n            }\n          }\n          return property\n        }\n        const report = api.current()\n        const counts = image.count(report.imageSpec)\n        console.log('report -----------------', JSON.stringify(report, null, 2))\n        console.log('counts-----------------', JSON.stringify(counts, null, 2))\n        if (context.selected) {\n          image.selecting(null, report.imageSpec)\n          const reportElements = getReportElements(report.select.reportElement)\n          const property = getProperty(reportElements, context.newState)\n          report.addRule(`.${context.selected.selected} ${stateToCSS(isA, property, context.newState)}`)\n        } else {\n          debugger\n          const reportElements = getReportElements(context.reportElement)\n          const lastContext = reportElements.slice(-1)[0]\n          const isPlural = lastContext.number == 'many'\n          const state = context.newState\n          const property = getProperty(reportElements, state)\n          const css = stateToCSS(isA, property, state)\n          if (isPlural || image.countSelected(report.imageSpec, reportElements) == 1) {\n            // make sure the state exactely matches correct CSS because the delete \"make the header not blue' needs that\n            const selector = image.selector(report.imageSpec, reportElements)\n            if (css) {\n              if (state.negated) {\n                report.removeRule(`${selector} ${css}`)\n              } else {\n                report.addRule(`${selector} ${css}`)\n              }\n            }\n          } else {\n            image.selecting('header', report.imageSpec)\n            if (!report.imageSpec.rules) {\n              report.imageSpec.rules = []\n            }\n            report.imageSpec.rules.push(`.highlight ${css}`)\n            report.select = context\n          }\n          /*\n          if (lastContext.marker == 'header') {\n            if (lastContext.number == 'many' || counts.header == 1) {\n              // make sure the state exactely matches correct CSS because the delete \"make the header not blue' needs that\n              const state = context.newState\n              const property = getProperty(getReportElements(context))\n              const css = stateToCSS(isA, property, state)\n              if (css) {\n                if (state.negated) {\n                  report.removeRule(`.header ${css}`)\n                } else {\n                  report.addRule(`.header ${css}`)\n                }\n              }\n            } else {\n              selecting('header', report.imageSpec)\n              report.select = context\n            }\n          }\n          */\n        }\n        api.show(report)\n      }"
        },
        {
          "id": "capitalize",
          "parents": [
            "verby"
          ],
          "bridge": "{ ...next(operator), element: after[0] }",
          "generatorp": "({context, gp}) => `${context.word} ${gp(context.element)}`",
          "semantic": "({context, mentions, api}) => {\n        const report = api.current()\n        if (context.element.marker == 'header') {\n          report.imageSpec.capitalizeHeader = true\n          if (report.imageSpec.explicit) {\n            report.imageSpec.rows.forEach( (row) => {\n              row.forEach( (column) => {\n                column.capitalizeHeader = true\n              })\n            })\n          }\n          api.show(report)\n        } else if (context.element.marker == 'this') {\n          if (context.selected) {\n            console.log('the user selected', context.selected)\n            const imageSpec = report.imageSpec\n            report.addRule(`.${context.selected.selected} { text-transform: capitalize; }`)\n            imageSpec.headers.selecting = null\n            imageSpec.headers.columns.forEach( (column) => column.selecting = null )\n            api.show(report)\n          } else {\n            /*\n            const headerIds = []\n            for (let ctr = 0; ctr < report.imageSpec.headers.length; ++ctr) {\n              headerIds.push(['report', 0, 'header', ctr])\n            }\n            */\n            if (report.imageSpec.headers) {\n              report.imageSpec.headers.columns.forEach( (column, index) => {\n                column.selecting = [{ id: `column_${index}`, name: 'X', className: `column_${index}` }]\n              })\n              report.imageSpec.headers.selecting = [{ id: 'header', name: 'X', className: 'header' }]\n            }\n            /*\n            report.imageSpec.selecting = {\n              headers: {\n                each: headerIds,\n                all: [0, 'header'],\n              },\n            }\n            */\n            report.select = context\n            console.log(\"after capitalize\", JSON.stringify(report, null, 2))\n            api.show(report)\n          }\n        }\n      }"
        },
        {
          "id": "this",
          "parents": [
            "reportElement"
          ]
        },
        {
          "id": "reportElement"
        },
        {
          "id": "header",
          "words": [
            {
              "word": "header",
              "number": "one"
            },
            {
              "word": "headers",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement"
          ]
        },
        {
          "id": "background",
          "words": [
            {
              "word": "background",
              "number": "one"
            },
            {
              "word": "backgrounds",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement",
            "reportElementProperty"
          ]
        },
        {
          "id": "table",
          "words": [
            {
              "word": "table",
              "number": "one"
            },
            {
              "word": "tables",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement"
          ]
        },
        {
          "id": "report",
          "parents": [
            "theAble"
          ]
        },
        {
          "id": "reportable"
        },
        {
          "id": "show",
          "bridge": "{ ...next(operator), show: after[0] }",
          "parents": [
            "verby"
          ],
          "generatorp": "({context, g}) => `show ${g(context.show)}`",
          "semantic": "({context, km, mentions, api, flatten, gp}) => {\n        const report = api.current()\n        const toArray = (context) => {\n          if (context.isList) {\n            return context.value\n          } else {\n            return [context]\n          }\n        }\n\n        const properties = toArray(context.show)\n\n        // split by table\n        const components = {}\n        for (const property of properties) {\n          if (!components[property.database]) {\n            components[property.database] = {}\n          }\n          const dbs = components[property.database]\n          if (!dbs[property.collection]) {\n            dbs[property.collection] = []\n          }\n          const collection = dbs[property.collection]\n          collection.push(property)\n        }\n\n        const dataSpecs = []\n        const imageSpecs = []\n        for (const dbName in components) {\n          for (const collectionName in components[dbName]) {\n            dataSpecs.push({\n                dbName: dbName,\n                collectionName: collectionName,\n                limit: 10,\n                aggregation: [] \n            })\n            const properties = components[dbName][collectionName]\n            imageSpecs.push({\n              headers: {\n                columns: properties.map( (c) => { return { text: gp(c) } })\n              },\n              colgroups: properties.map( (e, i) => `column_${i}` ),\n              table: true,\n              field: [],\n              // rows: ['$name', '$age', '$fav_colors'],\n              rows: properties.map( (property) => property.path.map((p) => '$'+p).join('.') )\n            })\n          }\n        }\n\n        if (dataSpecs.length == 1) {\n          report.dataSpec = dataSpecs[0]\n          report.imageSpec = imageSpecs[0]\n        } else {\n          report.dataSpec = dataSpecs\n          for (let i = 0; i < imageSpecs.length; ++i) {\n            imageSpecs[i].field = [i]\n          }\n          report.imageSpec = {\n            headers: { columns: [] },\n            table: true,\n            explicit: true,\n            field: [],\n            rows: [imageSpecs]\n          }\n        }\n        /*\n        report.dataSpec = { \n          dbName: properties[0].database, \n          collectionName: properties[0].collection, \n          aggregation: [] \n        }\n\n        report.imageSpec = {\n          headers: properties.map( gp ),\n          table: true,\n          field: [],\n          // rows: ['$name', '$age', '$fav_colors'],\n          rows: properties.map( (property) => property.path.map((p) => '$'+p).join('.') )\n        }\n        */\n\n        api.show(report)\n      }"
        },
        {
          "id": "sales",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "sales",
              "database": "mongo_test_database",
              "collection": "sales",
              "path": [
                "sales"
              ]
            }
          ]
        },
        {
          "id": "year",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "year",
              "database": "mongo_test_database",
              "collection": "sales",
              "path": [
                "year"
              ]
            }
          ]
        },
        {
          "id": "user",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "users",
              "database": "sample_mflix",
              "collection": "users",
              "path": [
                "name"
              ]
            }
          ]
        },
        {
          "id": "email",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "email",
              "database": "sample_mflix",
              "collection": "users",
              "path": [
                "email"
              ]
            }
          ]
        },
        {
          "id": "movie",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "movies",
              "database": "sample_mflix",
              "collection": "movies",
              "path": [
                "title"
              ]
            }
          ]
        }
      ],
      "priorities": [
        {
          "context": [
            [
              "show",
              0
            ],
            [
              "list",
              0
            ]
          ],
          "choose": [
            1
          ]
        }
      ]
    }
  ],
  "resultss": [
    {
      "extraConfig": true,
      "name": "mongo",
      "operators": [
        "([make] ([report]))",
        "([state])",
        "([changeState|make] ([reportElement]) (state/*))",
        "([reportElementProperty])",
        "((reportElement/* && !@<color_colors && !@<case) [compoundReportElement] (reportElement/* && !@<color_colors && !@<case))",
        "([background])",
        "([header])",
        "([table])",
        "([case])",
        "([uppercase])",
        "([lowercase])",
        "([reportable])",
        "([show] ([reportable]))",
        "([capitalize] ([reportElement]))",
        "([sales|])",
        "([year])",
        "([user])",
        "([email])",
        "([movie])",
        "([thisReportElement|this] (reportElement/*))"
      ],
      "hierarchy": [
        [
          "color_colors",
          "state"
        ],
        [
          "case",
          "state"
        ],
        [
          "color_colors",
          "reportElement"
        ],
        [
          "case",
          "reportElement"
        ]
      ],
      "bridges": [
        {
          "id": "case",
          "words": [
            {
              "word": "case",
              "number": "one"
            },
            {
              "word": "cases",
              "number": "many"
            }
          ],
          "isA": [
            "reportElementProperty"
          ]
        },
        {
          "id": "uppercase",
          "words": [
            {
              "word": "upper",
              "number": "one",
              "value": "uppercase"
            },
            {
              "word": "uppers",
              "number": "many",
              "value": "uppercase"
            }
          ],
          "isA": [
            "case"
          ]
        },
        {
          "id": "lowercase",
          "words": [
            {
              "word": "lower",
              "number": "one",
              "value": "lowercase"
            },
            {
              "word": "lowers",
              "number": "many",
              "value": "lowercase"
            }
          ],
          "isA": [
            "case"
          ]
        },
        {
          "id": "reportElementProperty"
        },
        {
          "id": "compoundReportElement",
          "convolution": true,
          "isA": [
            "reportElement",
            "theAble"
          ],
          "bridge": "{ ...next(operator), reportElements: append(default(before[0].reportElements, [before[0]]), default(after[0].reportElements, [after[0]])) }"
        },
        {
          "id": "make",
          "bridge": "{ ...next(operator), report: after[0] }",
          "parents": [
            "verby"
          ]
        },
        {
          "id": "state",
          "bridge": "{ ...next(operator) }"
        },
        {
          "id": "thisReportElement",
          "parents": [
            "articlePOS"
          ],
          "bridge": "{ ...next(after[0]), modifiers: append(['this'], after[0].modifiers), this: operator }"
        },
        {
          "id": "changeState",
          "bridge": "{ ...next(operator), reportElement: after[0], newState: after[1] }",
          "parents": [
            "verby"
          ]
        },
        {
          "id": "capitalize",
          "parents": [
            "verby"
          ],
          "bridge": "{ ...next(operator), element: after[0] }"
        },
        {
          "id": "this",
          "parents": [
            "reportElement"
          ]
        },
        {
          "id": "reportElement"
        },
        {
          "id": "header",
          "words": [
            {
              "word": "header",
              "number": "one"
            },
            {
              "word": "headers",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement"
          ]
        },
        {
          "id": "background",
          "words": [
            {
              "word": "background",
              "number": "one"
            },
            {
              "word": "backgrounds",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement",
            "reportElementProperty"
          ]
        },
        {
          "id": "table",
          "words": [
            {
              "word": "table",
              "number": "one"
            },
            {
              "word": "tables",
              "number": "many"
            }
          ],
          "parents": [
            "theAble",
            "reportElement"
          ]
        },
        {
          "id": "report",
          "parents": [
            "theAble"
          ]
        },
        {
          "id": "reportable"
        },
        {
          "id": "show",
          "bridge": "{ ...next(operator), show: after[0] }",
          "parents": [
            "verby"
          ]
        },
        {
          "id": "sales",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "sales",
              "database": "mongo_test_database",
              "collection": "sales",
              "path": [
                "sales"
              ]
            }
          ]
        },
        {
          "id": "year",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "year",
              "database": "mongo_test_database",
              "collection": "sales",
              "path": [
                "year"
              ]
            }
          ]
        },
        {
          "id": "user",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "users",
              "database": "sample_mflix",
              "collection": "users",
              "path": [
                "name"
              ]
            }
          ]
        },
        {
          "id": "email",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "email",
              "database": "sample_mflix",
              "collection": "users",
              "path": [
                "email"
              ]
            }
          ]
        },
        {
          "id": "movie",
          "parents": [
            "reportable",
            "theAble"
          ],
          "words": [
            {
              "word": "movies",
              "database": "sample_mflix",
              "collection": "movies",
              "path": [
                "title"
              ]
            }
          ]
        }
      ],
      "priorities": [
        {
          "context": [
            [
              "show",
              0
            ],
            [
              "list",
              0
            ]
          ],
          "choose": [
            1
          ]
        }
      ]
    }
  ],
  "fragments": [],
  "semantics": [],
  "associations": [],
  "learned_contextual_priorities": []
}